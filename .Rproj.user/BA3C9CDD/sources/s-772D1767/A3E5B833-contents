library(plotly)
library(stringr)
library(reshape2)
library(KernSmooth)
mtcars<-data.frame(yc1=rnorm(1000000,0,sd = 0.1),
                   ye1=rnorm(1000000,0,sd = 9.9),
                   yc2=rnorm(1000000,0,sd = 5),
                   ye2=rnorm(1000000,0,sd = 5))
mtcars$D1=mtcars$ye1-mtcars$yc1
mtcars$D2=mtcars$ye2-mtcars$yc2
sd(mtcars$D1);sd(mtcars$D2)
var(mtcars$D1);var(mtcars$D2)
summary(mtcars$D1);summary(mtcars$D2)

# par(mfrow=c(1,3))
# est1<-bkde2D(mtcars[,1:2],bandwidth=c(0.7, 7))
# contour(est1$x1, est1$x2, est1$fhat)
# est2<-bkde2D(mtcars[,3:4],bandwidth=c(0.7, 7))
# contour(est2$x1, est2$x2, est2$fhat)
est3<-bkde2D(mtcars[,5:6],bandwidth=c(0.7, 7),gridsize = c(91L, 91L))
contour(est3$x1, est3$x2, est3$fhat)
# Create a sequence of incrementally increasing (by 0.3 units) values for both wt and hp
xgrid <-  seq(min(mtcars$yc1), max(mtcars$yc1), 0.3)
ygrid <-  seq(min(mtcars$ye1), max(mtcars$ye1), 0.3)
bkde2D
# Generate a dataframe with every possible combination of wt and hp
data.fit <-  expand.grid(wt = xgrid, hp = ygrid)
# Feed the dataframe into the loess model and receive a matrix output with estimates of
# acceleration for each combination of wt and hp
mtrx3d <-  predict(data.loess, newdata = data.fit)
# Abbreviated display of final matrix
mtrx3d[1:4, 1:4]

##           hp
## wt         hp= 52.0 hp= 52.3 hp= 52.6 hp= 52.9
##   wt=1.513 19.04237 19.03263 19.02285 19.01302
##   wt=1.813 19.25566 19.24637 19.23703 19.22764
##   wt=2.113 19.55298 19.54418 19.53534 19.52645
##   wt=2.413 20.06436 20.05761 20.05077 20.04383

# Transform data to long form
mtrx.melt <- melt(mtrx3d, id.vars = c('wt', 'hp'), measure.vars = 'qsec')
names(mtrx.melt) <- c('wt', 'hp', 'qsec')
# Return data to numeric form
mtrx.melt$wt <- as.numeric(str_sub(mtrx.melt$wt, str_locate(mtrx.melt$wt, '=')[1,1] + 1))
mtrx.melt$hp <-  as.numeric(str_sub(mtrx.melt$hp, str_locate(mtrx.melt$hp, '=')[1,1] + 1))

fig <- plot_ly(mtrx.melt, x = ~wt, y = ~hp, z = ~qsec, type = "contour",
               width = 600, height = 500)

fig
